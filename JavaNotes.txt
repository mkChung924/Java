
--------------[ Hello, Java ] ---------------

///DAY 1///

* 환경변수
1. path:"%JAVA_HOME%\bin",Classpath:".;%JAVA_HOME\lib",JAVA_HOME:"C:\Program Files\Java\jdk1.8.0_121"

* 에딧 텍스트
1. 빌드 만들기
 기본설정- 메뉴제목"컴파일(javac),명령:javac.exe경로설정,인수:파일이름,디렉토리:파일디렉토리,출력
2. 빌드 보여주기
 기본설정- 메뉴제목"실행(java),명령:java.exe경로설정,인수:$(FileNameNoExt),디렉토리:파일디렉토리,출력

* 프로그램 구성 요소
1. 필드(field,변수) - 속성, 자료구조, 데이터
 -> 데이터를 담는 그릇

2. 메소드(method) - 기능, 행위
  = 함수

3. 클래스(class) - 자바 P/G 기본 단위
		 - 파일 저장단위

<구성요소 구분>
1. 필드 - 소문자, 이름뒤에 소괄호()를 포함X
 ex) out
2. 메소드 - 소문자, 이름뒤에 소괄호()를 포함O
 ex) println()
3. 클래스-첫글자 대문자
 ex) System

<구성요소 형식>
1. 필드(=변수)
  자료형 + 변수명; //변수선언
  -> 자료형은 변수가 담길 그릇(=형태)
  변수명 = 데이터; //변수초기화


<자바 자료형> Data Type

[1] 기본자료형 8개
1. 문자 char
 ex) char ch ;
     ch = 'A';

2. 숫자
 1) 정수
  byte  =1byte= 8bit=2^8=256(-128~127)
  short =2byte=16bit=
  int   =4byte=32bit=
  long  =8byte=64bit=

 2) 실수
  float =4byte=32bit=
  double=8byte=64bit=

 3) 논리
  boolean s;
  s = True;
  s = Flase;


[2] 클래스 자료형
1. 문자열 String -> 0개 이상의 문자표현
  ex) String str;
      str = "홍길동";
      str = "":

<식별자 이름 규칙>
1. 예약어 사용 불가
 ex) int public; // 이미 쓰이는 단어들 쓰면 안됨

2. 특수문자 사용불가(@,#,%...)
 예외) _,$

3. 첫글자 숫자 불가
 ex) int 2su; // 에러 -> int su2;

4. 한글사용 가능
 -> 자바가 유니코드체계 지원 16bit. But, 비추
 ex) int 숫자 = 13; // 가능은 함

///DAY 2///

<매소드 형식>

리턴자료형 메소드명()<-매개변수(parameter 또는 arguments)가 들어감:데이터 전달 변수

  {<- 시작


  }<- 끝

리턴자료형 : 기본자료형 8 + 클래스 + void

ex)

void gildong()
{
1. 창문 앞으로 이동;
2. 창문 열기;
3. 제자리로 돌아옴;
	(return;)<-생략가능
}

커피 lime()
{
1. 자판기 앞으로 이동;
2. 동전 투입;
3. 버튼 클릭;
4. 커피 뽑기;
5. 커피를 가지고 되돌아오기;
		(return 커피;)<-생략불가능
}

콜라 juwon(int coin)
{
1. 자판기 앞으로 이동;
2. 동전 투입;
3. 버튼 클릭;
4. 콜라 뽑기;
5. 콜라를 가지고 되돌아오기;
		(return 콜라;)<-생략불가능
}

<클래스 형식>

class 클래스명
{

*class안에는 이 두가지만 들어간다.

//1. 변수 선언(초기화 홀로 불가, 선언 및 초기화는 가능)
	int su;       o
	su = 13;      x
	int su2 = 20; o

//2. 메소드 정의
   void gildong(변수 선언)
{
 //1. 변수 선언
 //2. 변수 초기화
 //3. 메소드 호출
 //4. 조건문, 반복문

}

}

- 클래스의 파일명은 클래스명.java로 저장한다.
- 클래스 내부에 main이 없으면 독립적으로 실행되지 않는다.(에러발생)
- main을 포함하고 있는 클래스를 우리는 JAVA Application 이라 부른다.
  JAVA Application : 독립적으로 실행할 수 있는 main() 메소드를 포함한 클래스
  그 외: 자바 class

- 그 외 메소드는 다른 곳에서 사용가능
  B b = new B();
  b.gildong();

※ 클래스 사용은 어떻게?
-----> 객체를 생성(=메모리할당)해서 사용한다.
-----> ★객체 생성식:
	    A 	   	obj  	  =      new 	     A();
	클래스명 (레퍼런스)변수명 = 객체생성키워드 클래스명()
		      참조변수

	====> A클래스를 사용할 준비가 끝났다.
	====> A클래스내의 필드 또는 메소드를 사용할 준비가 끝났다.

ex)

   class A{
	void hello(){
	   System.out.println("안녕~");
	}
}

   class B{
	void hello(){
	   System.out.println("신짜오~");
	}

}

   class CallTest{
	public static void main(String args[]){
	
		A a = new A();
		a.hello();
		B b = new B();
		b.hello();
	}

}

<자바주석문> 설명문, comment
1. 라인주석 //
	//설명문1
	//설명문2

2. 블럭주석 /* */

	/*
	설명문1
	설명문2
	설명문3
	*/

<변수 선언>

ㅁ 변수명;
ㅁ : 기본자료형 + 클래스

int su;
su : 속성변수(데이터를 저장하는 변수)

A(클래스) su2;
su2 : 참조변수

<연산자>

1.산술연산자
   + - * / %

	10/5 ----> 2
	10/3 ----> 3
	10%3 ----> 1

2.증감연산자
   ++, --

   int su;
	su = 0;
	----> 증가 연산자 또는 감소 연산자는 초기화된 변수 앞 또는 뒤에 붙여 사용!

	su++(후위연산자,나중연산자)//----> su = su + 1;
	++su(전위연산자,먼저연산자)//----> su = su + 1;

	차이점)
	  int su1 = 5;
	  int su2 = 5;

	  int sum1, sum2;
	  int sum1 = 0, sum2 = 0;

	case1) 후위연산자
		sum1 = su1++;
		----->sum1:5, su1:6


	case2) 전위연산자
		sum2 = ++su2;
		-----> sum2 : 6, su2 : 6

	※참고 : 2증가, 3증가?
	int a = 0;
	   a++ // a = a + 1;

	   a+=2 // a = a + 2;
	   a+=3 // a = a + 3;

	   a*=5 // a = a * 5;

3.비교(관계)연산자
   > : 크다, < : 작다, >= : 크거나 같다, <= : 작거나 같다, == : 같다, != : 같지않다

   =====> 결과값이 boolean!!

	int a = 3;
	int b = 4;

	a < b ===> true
	a > b ===> false
	a==b ====> false
	a!=b ====> true

4.논리연산자
   && : and연산자 : 두개의 조건이 동시에 만족(true)했을때만 결과값이 true
   || : or연산자 : 한개의 조건이라도 만족한다면 결과값이 true

	가정) true를 1, false를 0이라고 표현.

	A && B ----> A와 B는 반드시 boolean

	0    0 ----> false
	0    1 ----> false
	1    0 ----> false
	1    1 ----> true

	A || B ----> A와 B는 반드시 boolean

	0    0 ----> false
	0    1 ----> true
	1    0 ----> true
	1    1 ----> true

문제) y는 실행 될 것인가? No! 프로그램은 false를 먼저 만나면 뒤는 연산하지 않음.

   int a = 5;
   int b = 6;
   int c = 10;
   int d = 3;

	(a < b) && (c>d)
	-------	   ------
	   X 	     Y

문제) 윤년의 조건
  1. 연도를 4로 나우었을 때 나머지가 0이고
     연도를 100으로 나누었을 때 나머지가 0이 아닌 경우.

  2. 연도를 400으로 나누었을 때 나머지가 0인 경우.


<조건문>

1.if문
   - 조건식에 만족(true)했을 때 실행할 문장을 명시하기 위해 사용.

	형식)
	
		if(조건식) //조건식 : boolean데이터
		{
		   //조건식 결과가 참일 때 실행할 문장들.
		}

	※만약 조건식 결과가 참일 때 실행할 문장이 한 개라고 한다면
	  영역 괄호를 생략하는 것이 가능!!

	   예) if(3<4){
		문장1;
		문장2;
		}
		문장3;
		문장4;
	-------------------> 실행문장? 1,2,3,4 모두

	   예) if(3>4)
		문장1;
		문장2;
		문장3;
		문장4
	-------------------> 실행문장? 2,3,4


2. if~else문
    - 조건이 참일 때 실행할 문장과
	거짓일 때 실행할 문장을 각각 명실할 때 사용.

	형식)
		if(조건식){
		   //조건식 결과가 참일 때 실행할 문장들.
		} else {
		   //조건식 결과가 거짓일 때 실행할 문장들.
		}

	※주의) else문은 반드시 if영역 뒤에 사용되며 홀로 사용하면 안됨.


	   예) if(3<4){
		문장1;
		문장2;
		} else {
		문장3;
		문장4;
		}
		문장5;
	-------------------> 실행문장? 1,2,5

	   예) if(3>4){
		문장1;
		문장2;
		} else {
		문장3;
		문장4;
		}
		문장5;
	-------------------> 실행문장? 3,4,5

	   예) if(3<4)
		{문장1;} <-이런식으로 프로그램이 알아서 {}를 쳐줘서 ELSE에서 에러남
		문장2;
		else   //에러 발생
		문장3;
		문장4;
		
		문장5;
	-------------------> 실행문장? 에러
	
///DAY 03///
	
3. switch~case문
   - 전달되는 데이터와 일치하는 값을 찾았을때 
     실행할 문장을 가독성 좋게 표현할 때 사용.

  형식)
      switch(표현식){ //표현식 데이터: 정수(byte,short,int),문자(char)
                      //JDK7버전부터 String문자열 추가!!
         case 값1: 실행할 문장; break;
	 case 값2: 실행할 문장; break;
	 case 값3: 실행할 문장; break;
	 default: 실행할 문장;
	    //일치하는 case 값이 없을 때 실행할 문장을 정의.
      }

   예)
       int su=4;

       switch(su){
         case 1: 문장1; break;
	 case 3: 문장2; break;
	 case 5: 문장3;
       }

   문제) 학점출력하기
         int jumsu=85;  //jumsu에는 0~100까지의 정수값이 입력된다는 가정.

        jumsu     출력
	90~100    A학점
        80~89     B학점
        70~79     C학점
        60~69     D학점
        0~59      F학점

4. if ~ else if ~ else문
   - 연결되어지는 여러개의 조건식을 적용할 때 사용.
   - 범위조건식을 표현할 때 많이 사용.

  형식)
     if(조건식1){
         //조건식1이 참일때 실행할 문장.
     }else if(조건식2){
         //조건식1이 거짓이고 조건식2가 참일때 실행할 문장.
     }else if(조건식3){
         //조건식1,2가 거짓이고 조건식3이 참일때 실행할 문장.
     }else{//switch~case의 default와 같은 의미!!, 생략가능
         //조건식1,2,3이 거짓이었을때 실행할 문장.
     }

<반복문> Loop
1. for문
  - 일정횟수 반복할 경우 사용.
  - 규칙적인 수를 표현 할 때 사용.
  - 배열,List를 표현 할 때 사용.

  형식)
       for(1.초기화;  2.조건식;  3.증감연산자){
                    //4.조건식을 만족했을 때 반복실행할 문장들.       
       }

  실행순서)
           1 - 2(t) - 4 - 3
	       2(t) - 4 - 3
               2(t) - 4 - 3
               2(t) - 4 - 3
               2(f) --------> for문 벗어나기!!
  예)
        for(int i=0; i<5; i++){ //i의 값이 0,1,2,3,4였을 때 실행.
	   System.out.println("안녕~!!");
	}

문제1) 아래와 같이 화면에 출력하시오.
    1
    2
    3
    4
    5

문제2) 아래와 같이 화면에 출력하시오.
  1 2 3 4 5

문제3) 아래와 같이 화면에 출력하시오.
  3 6 9 12

문제4) 아래와 같이 화면에 출력하시오.
  [5, 10, 15, 20]
   
문제5) 아래와 같이 화면에 출력하시오.
  5 4 3 2 1


2. while문
  - 대기모드를 표현할 때 사용.
  - if문이 조건식 결과에 따라 0번, 1번 실행한다면
    while문은 조건식 결과에 따라 0~무한대 실행.

  형식)
    while(조건식){
       //조건식의 결과가 참일 동안 실행할 문장들.
    }


3. do~while문
   - while문과 동일하게 실행되지만
     처음 반복되는 문장은 조건식 결과에 상관없이 실행!!
   - 실행횟수: 1~무한대

 형식)
       do{
          //조건식의 결과가 참일 동안 실행할 문장들.       
         }while(조건식);

======================================================
<<객체지향의 특징>>

1. 캡슐화 : 필드와 메소드를 클래스에 묶어두는 것.
  - 정보은닉(private)
  - 모듈성

2. 상속 ★
  - 부모클래스가 갖는 모든 속성과 기능을 자식에게 물려 주는 것.
  - 단일상속이 기본(한개의 부모클래스 상속만 받을 수 있다)
  - 키워드: extends

  class 클래스 extends 부모클래스명
  {       의미: is a
        ===> 자식은 부모다!!
	     (자식클래스는 부모클래스로 자료형 변환이 된다) 
  }
  - 부모클래스(상위클래스, super클래스)
  - 자식클래스(하위클래스, sub클래스)
  - Object클래스는 최상위클래스 : 모든 자바객체의 최고 상위클래스임!!

3. 다형성
  - Method Overloading(오버로딩)
    : 한 클래스내에서 동일한 이름의 메소드를 여러개 구현(정의)하는 것.
      (단, 인자의 갯수나 자료형이 달라야 함!!)
    
    class A{
      int su;
      int su; ==> 에러발생!!:같은 영역에 동일한 이름의 변수를 
                             두 번이상 자료형 선언하는 것은 불가!!
      void hello(){}
      void hello(){} ==> 에러발생!!
    }

  - Method Overriding(오버라이딩) ★★
    : 상속에서 나온 개념
    : 메소드 재정의
      (부모클래스에서 정의된 메소드를 자식클래스에서 다시 정의)

 
class Parent{}
class Child extends Parent{}

class Test{
   void main(){
       Parent p = new Parent();
       Child c = new Child();
    ---------------------------------
       Parent p2 = new Child(); 1.
         Parent p2;//기준
	        p2 = new Child();

       Child c2 = new Parent(); 2.
         Child c2;//기준
	       c2 = new Parent();   ===>에러발생!!
   }
}


